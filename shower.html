<!DOCTYPE html>
<html>
<head><title>Shower Graphs</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="theme-color" content="#00838F">
	<link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
	<link rel="stylesheet" href="css/material-components-web.min.css">
	<script src="js/material-components-web.min.js"></script>
	<script src="js/highcharts.js"></script>
</head>
<body>
<header class="mdc-toolbar mdc-toolbar--fixed mdc-toolbar--waterfall">
	<div class="mdc-toolbar__row">
		<section class="mdc-toolbar__section mdc-toolbar__section--align-start">
			<a id="menu" href="#" class="material-icons mdc-toolbar__icon--menu">menu</a>
			<span class="mdc-toolbar__title">Shower Graphs</span>
		</section>
	</div>
</header>
<aside class="mdc-temporary-drawer mdc-typography">
	<nav class="mdc-temporary-drawer__drawer">
		<header class="mdc-temporary-drawer__header">
			<div class="mdc-temporary-drawer__header-content">
				Showers
			</div>
		</header>
		<nav id="shower-list" class="mdc-temporary-drawer__content mdc-list mdc-list--two-line mdc-list--dense">
		</nav>
	</nav>
</aside>
<main class="mdc-toolbar-fixed-adjust">

	<div class="col-sm-9">
		<div class="panel-body" id="FLOW"></div>

		<div class="panel-body" id="TEMP"></div>

		<div id="scale"></div>

		<div id="mag"></div>

		<div id="acc"></div>

		<div id="gyr"></div>
	</div>
</main>
<script>
	function query(query) {
		return fetch("http://jzcpi1.local:8086/query?db=shower&epoch=ms&q=" + query)
			.then((res) => res.json())
	}

	function drawGraph2(series, axisA, axisB, axisC, start, end, container, ylable) {
		query("select value from " + series + " where axis = '" + axisA + "' and time > " + start + "ms and time < " + end + "ms order by time asc")
			.then((dataA) => {
				query("select value from " + series + " where axis = '" + axisB + "' and time > " + start + "ms and time < " + end + "ms order by time asc")
					.then((dataB) => {
						query("select value from " + series + " where axis = '" + axisC + "' and time > " + start + "ms and time < " + end + "ms order by time asc")
							.then((dataC) => {
								if (dataA.results[0].series) {
									dataA = dataA.results[0].series[0].values;
								}

								if (dataB.results[0].series) {
									dataB = dataB.results[0].series[0].values;
								}

								if (dataC.results[0].series) {
									dataC = dataC.results[0].series[0].values;
								}

								Highcharts.chart(container, {
									chart: {
										zoomType: 'x'
									},
									title: {text: ''},
									xAxis: {
										type: 'datetime',
										min: start,
										max: end,
										title: {
											text: 'timestamp'
										}
									},
									yAxis: {
										title: {
											text: ylable
										}
									},
									tooltip: {
										headerFormat: '<b>{series.name}</b><br>',
										pointFormat: '{point.y:.1f} {point.x:%e %b, %H:%M:%S}'
									},

									plotOptions: {
										scatter: {
											marker: {
												enabled: true,
												radius: 1.5
											}
										}
									},

									series: [{
										name: axisA,
										data: dataA
									}, {
										name: axisB,
										data: dataB
									}, {
										name: axisC,
										data: dataC
									}]
								});
							});
					});
			});
	}

	function drawGraph(series, axisA, start, end, container, ylable) {
		query("select value from " + series + " where axis = '" + axisA + "' and time >= " + start + "ms and time <= " + end + "ms order by time asc")
			.then(function (dataA) {
				if (dataA.results[0].series) {
					dataA = dataA.results[0].series[0].values;
				}

				Highcharts.chart(container, {
					chart: {
						zoomType: 'x'
					},
					title: {text: ''},
					legend: {enabled: false},
					xAxis: {
						type: 'datetime',
						min: start,
						max: end,
					},
					yAxis: {
						title: {
							text: ylable
						},
						min: 0
					},
					tooltip: {
						headerFormat: '<b>{series.name}</b><br>',
						pointFormat: '{point.x:%H:%M:%S}, {point.y:.1f}'
					},

					plotOptions: {
						area: {
							fillColor: {
								linearGradient: {
									x1: 0,
									y1: 0,
									x2: 0,
									y2: 1
								},
								stops: [
									[0, Highcharts.getOptions().colors[0]],
									[1, Highcharts.Color(Highcharts.getOptions().colors[0]).setOpacity(0).get('rgba')]
								]
							},
							marker: {
								radius: 2
							},
							lineWidth: 1,
							states: {
								hover: {
									lineWidth: 1
								}
							},
							threshold: null
						}
					},

					series: [
						{
							name: axisA,
							data: dataA
						}
					]
				});
			});
	}

	function htmlToElement(html) {
		const template = document.createElement('template');
		template.innerHTML = html;
		return template.content.firstChild;
	}

	function loadShower(start, end) {
		drawGraph("monitor", "FLOW", start, end, 'FLOW', "Flow litres/min");
		drawGraph("monitor", "TEMP", start, end, 'TEMP', "Temperature ÂºC");
		drawGraph("scale", "scale", start, end, 'scale', "Weight change g");
		drawGraph2("head", "ax", "ay", "az", start, end, 'acc', "g", "Head Accelerometer");
		drawGraph2("head", "mx", "my", "mz", start, end, 'mag', "g", "Head Magnetometer");
		drawGraph2("head", "gx", "gy", "gz", start, end, 'gyr', "g", "Head Gyroscope");
	}

	query("select value from startstop")
		.then(function (data) {
			const listElement = document.getElementById('shower-list');
			while (listElement.hasChildNodes()) {
				listElement.removeChild(listElement.lastChild);
			}

			let newShower = {};
			for (let item of data.results[0].series[0].values) {
				if (item[1] === 1) {
					newShower.start = item[0];
					let date = new Date(item[0]);
					newShower.date = date.toLocaleString('en-GB', {
							day: 'numeric', month: 'short',
							hour: 'numeric', minute: '2-digit'
						});
				} else {
					if ('start' in newShower) {
						newShower.end = item[0];
						let length = newShower.end - newShower.start;
						if(length > 60000) {
							newShower.length = Math.round(length / 60000) + " min";
						} else {
							newShower.length = Math.round(length / 1000) + " sec";
						}

						if(!listElement.hasChildNodes()) {
							loadShower(newShower.start, newShower.end);
						}

						// Append Item to menu
						listElement.appendChild(htmlToElement('<a onclick="loadShower(' + newShower.start + ',' + newShower.end + ')" class="mdc-list-item"><span class="material-icons mdc-list-item__start-detail">show_chart</span><span class="mdc-list-item__text">Shower ' + newShower.date + '<span class="mdc-list-item__text__secondary">' + newShower.length + '</span></span></a>'));
					}
					newShower = {};
				}
			}
		});

	mdc.autoInit();

	let toolbar = mdc.toolbar.MDCToolbar.attachTo(document.querySelector('.mdc-toolbar'));
	toolbar.fixedAdjustElement = document.querySelector('.mdc-toolbar-fixed-adjust');

	let drawer = new mdc.drawer.MDCTemporaryDrawer(document.querySelector('.mdc-temporary-drawer'));
	document.querySelector('#menu').addEventListener('click', () => drawer.open = true);
</script>
</body>
</html>